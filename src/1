#include "vk_utils.h"


static void destroy_swapchain_objects() {
    vkDeviceWaitIdle(gDevice);
    for (auto& f : gFrames) {
        if (f.framebuffer)   vkDestroyFramebuffer(gDevice, f.framebuffer, nullptr);
        if (f.inFlight)      vkDestroyFence(gDevice, f.inFlight, nullptr);
        if (f.renderFinished)vkDestroySemaphore(gDevice, f.renderFinished, nullptr);
        if (f.imageAvailable)vkDestroySemaphore(gDevice, f.imageAvailable, nullptr);
        if (f.cmd)           vkFreeCommandBuffers(gDevice, f.cmdPool, 1, &f.cmd);
        if (f.cmdPool)       vkDestroyCommandPool(gDevice, f.cmdPool, nullptr);
    }
    gFrames.clear();

    for (auto iv : gSwapchainImageViews) {
        vkDestroyImageView(gDevice, iv, nullptr);
    }
    gSwapchainImageViews.clear();

    if (gRenderPass) {
        vkDestroyRenderPass(gDevice, gRenderPass, nullptr);
        gRenderPass = VK_NULL_HANDLE;
    }
}

static void create_render_pass(VkFormat surfaceFormat) {
    VkAttachmentDescription color{};
    color.format         = surfaceFormat;
    color.samples        = VK_SAMPLE_COUNT_1_BIT;
    color.loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;
    color.storeOp        = VK_ATTACHMENT_STORE_OP_STORE;
    color.stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    color.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    color.initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;
    color.finalLayout    = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentReference colorRef{};
    colorRef.attachment = 0;
    colorRef.layout     = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    VkSubpassDescription subpass{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments    = &colorRef;

    VkSubpassDependency dep{};
    dep.srcSubpass = VK_SUBPASS_EXTERNAL;
    dep.dstSubpass = 0;
    dep.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dep.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dep.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

    VkRenderPassCreateInfo rpci{VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO};
    rpci.attachmentCount = 1;
    rpci.pAttachments    = &color;
    rpci.subpassCount    = 1;
    rpci.pSubpasses      = &subpass;
    rpci.dependencyCount = 1;
    rpci.pDependencies   = &dep;

    check_vk(vkCreateRenderPass(gDevice, &rpci, nullptr, &gRenderPass), "vkCreateRenderPass");
}

static void create_frame_data() {
    gFrames.resize(gImageCount);

    for (uint32_t i = 0; i < gImageCount; ++i) {
        auto& f = gFrames[i];

        // command pool / buffer
        VkCommandPoolCreateInfo cpci{VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};
        cpci.queueFamilyIndex = gGraphicsQueueFamily;
        cpci.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
        check_vk(vkCreateCommandPool(gDevice, &cpci, nullptr, &f.cmdPool), "vkCreateCommandPool");

        VkCommandBufferAllocateInfo cbai{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
        cbai.commandPool = f.cmdPool;
        cbai.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        cbai.commandBufferCount = 1;
        check_vk(vkAllocateCommandBuffers(gDevice, &cbai, &f.cmd), "vkAllocateCommandBuffers");

        // semaphores + fence
        VkSemaphoreCreateInfo sci{VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};
        check_vk(vkCreateSemaphore(gDevice, &sci, nullptr, &f.imageAvailable), "vkCreateSemaphore");
        check_vk(vkCreateSemaphore(gDevice, &sci, nullptr, &f.renderFinished), "vkCreateSemaphore");

        VkFenceCreateInfo fci{VK_STRUCTURE_TYPE_FENCE_CREATE_INFO};
        fci.flags = VK_FENCE_CREATE_SIGNALED_BIT;
        check_vk(vkCreateFence(gDevice, &fci, nullptr, &f.inFlight), "vkCreateFence");
    }
}

static void create_framebuffers(VkExtent2D extent) {
    for (uint32_t i = 0; i < gImageCount; ++i) {
        VkImageView attachments[] = { gSwapchainImageViews[i] };
        VkFramebufferCreateInfo fbci{VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO};
        fbci.renderPass = gRenderPass;
        fbci.attachmentCount = 1;
        fbci.pAttachments = attachments;
        fbci.width  = extent.width;
        fbci.height = extent.height;
        fbci.layers = 1;

        check_vk(vkCreateFramebuffer(gDevice, &fbci, nullptr, &gFrames[i].framebuffer), "vkCreateFramebuffer");
    }
}

static void create_imgui_descriptor_pool() {
    if (gImguiDescPool) return;
    VkDescriptorPoolSize pool_sizes[] = {
        { VK_DESCRIPTOR_TYPE_SAMPLER, 1000 },
        { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000 },
        { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000 },
        { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000 },
        { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000 },
        { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000 },
        { VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000 }
    };
    VkDescriptorPoolCreateInfo info{VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO};
    info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
    info.maxSets = 1000 * (uint32_t)(sizeof(pool_sizes)/sizeof(pool_sizes[0]));
    info.poolSizeCount = (uint32_t)(sizeof(pool_sizes)/sizeof(pool_sizes[0]));
    info.pPoolSizes = pool_sizes;
    check_vk(vkCreateDescriptorPool(gDevice, &info, nullptr, &gImguiDescPool), "vkCreateDescriptorPool");
}

static void create_swapchain_and_views() {
    // 通过 vk-bootstrap 基于现有 surface 选择设备 & 创建 swapchain
    vkb::PhysicalDeviceSelector selector{ gVkbInstance };
    selector.set_surface(gSurface);
    auto phys_ret = selector.set_minimum_version(1,1).select();
    if (!phys_ret) { LOGE("Select physical device failed"); abort(); }
    vkb::PhysicalDevice vkbPhys = phys_ret.value();
    gPhysical = vkbPhys.physical_device;

    vkb::DeviceBuilder dev_builder{ vkbPhys };
    auto dev_ret = dev_builder.build();
    if (!dev_ret) { LOGE("Create logical device failed"); abort(); }
    gVkbDevice = dev_ret.value();
    gDevice    = gVkbDevice.device;
    gGraphicsQueue = gVkbDevice.get_queue(vkb::QueueType::graphics).value();
    gGraphicsQueueFamily = gVkbDevice.get_queue_index(vkb::QueueType::graphics).value();

    vkb::SwapchainBuilder sc_builder{ gVkbDevice };
    auto sc_ret = sc_builder
        .use_default_format_selection()
        .set_desired_present_mode(VK_PRESENT_MODE_FIFO_KHR) // 移动端常用
        .add_image_usage_flags(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT)
        .build();

    if (!sc_ret) { LOGE("Create swapchain failed"); abort(); }
    gVkbSwapchain = sc_ret.value();
    gSwapchainImages     = gVkbSwapchain.get_images().value();
    gSwapchainImageViews = gVkbSwapchain.get_image_views().value();
    gImageCount          = (uint32_t)gSwapchainImages.size();

    VkSurfaceFormatKHR surfFmt = gVkbSwapchain.surface_format;
    create_render_pass(surfFmt.format);
    create_frame_data();
    create_framebuffers(gVkbSwapchain.extent);
}

// 字体上传：需要一次性 command buffer
static void imgui_upload_fonts() {
    VkCommandPoolCreateInfo cpci{VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};
    cpci.queueFamilyIndex = gGraphicsQueueFamily;
    cpci.flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT;
    VkCommandPool fontPool;
    check_vk(vkCreateCommandPool(gDevice, &cpci, nullptr, &fontPool), "vkCreateCommandPool(fonts)");

    VkCommandBufferAllocateInfo cbai{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
    cbai.commandPool = fontPool;
    cbai.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    cbai.commandBufferCount = 1;

    VkCommandBuffer cmd;
    check_vk(vkAllocateCommandBuffers(gDevice, &cbai, &cmd), "vkAllocateCommandBuffers(fonts)");

    VkCommandBufferBeginInfo bi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
    bi.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    check_vk(vkBeginCommandBuffer(cmd, &bi), "vkBeginCommandBuffer(fonts)");

    ImGui_ImplVulkan_CreateFontsTexture(cmd);

    check_vk(vkEndCommandBuffer(cmd), "vkEndCommandBuffer(fonts)");

    VkSubmitInfo si{VK_STRUCTURE_TYPE_SUBMIT_INFO};
    si.commandBufferCount = 1;
    si.pCommandBuffers = &cmd;
    check_vk(vkQueueSubmit(gGraphicsQueue, 1, &si, VK_NULL_HANDLE), "vkQueueSubmit(fonts)");
    check_vk(vkDeviceWaitIdle(gDevice), "vkDeviceWaitIdle(fonts)");

    ImGui_ImplVulkan_DestroyFontUploadObjects();
    vkDestroyCommandPool(gDevice, fontPool, nullptr);
}

static void rebuild_swapchain() {
    vkDeviceWaitIdle(gDevice);
    destroy_swapchain_objects();

    // 重建 swapchain
    auto sc_ret = vkb::SwapchainBuilder{ gVkbDevice }
        .use_default_format_selection()
        .set_desired_present_mode(VK_PRESENT_MODE_FIFO_KHR)
        .build();
    if (!sc_ret) { LOGE("Rebuild swapchain failed"); abort(); }
    gVkbSwapchain = sc_ret.value();
    gSwapchainImages     = gVkbSwapchain.get_images().value();
    gSwapchainImageViews = gVkbSwapchain.get_image_views().value();
    gImageCount          = (uint32_t)gSwapchainImages.size();

    VkSurfaceFormatKHR surfFmt = gVkbSwapchain.surface_format;
    create_render_pass(surfFmt.format);
    create_frame_data();
    create_framebuffers(gVkbSwapchain.extent);

    // 告诉 ImGui 新的 image count
    ImGui_ImplVulkan_SetMinImageCount(gMinImageCount);
}

// ----------------- 每帧渲染 -----------------
static void frame_render() {
    // 获取下一张交换链图像
    uint32_t imageIndex = 0;
    VkResult acq = vkAcquireNextImageKHR(
        gDevice, gVkbSwapchain.swapchain, UINT64_MAX,
        gFrames[0].imageAvailable, VK_NULL_HANDLE, &imageIndex);

    if (acq == VK_ERROR_OUT_OF_DATE_KHR || acq == VK_SUBOPTIMAL_KHR) {
        rebuild_swapchain();
        return;
    }
    check_vk(acq, "vkAcquireNextImageKHR");

    auto& f = gFrames[imageIndex];
    vkWaitForFences(gDevice, 1, &f.inFlight, VK_TRUE, UINT64_MAX);
    vkResetFences(gDevice, 1, &f.inFlight);
    vkResetCommandPool(gDevice, f.cmdPool, 0);

    // 记录命令
    VkCommandBufferBeginInfo bi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
    check_vk(vkBeginCommandBuffer(f.cmd, &bi), "vkBeginCommandBuffer");

    // 清屏色
    VkClearValue clear{};
    clear.color = {{0.05f, 0.05f, 0.07f, 1.0f}};

    VkRenderPassBeginInfo rpbi{VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO};
    rpbi.renderPass = gRenderPass;
    rpbi.framebuffer = f.framebuffer;
    rpbi.renderArea.offset = {0,0};
    rpbi.renderArea.extent = gVkbSwapchain.extent;
    rpbi.clearValueCount = 1;
    rpbi.pClearValues    = &clear;

    vkCmdBeginRenderPass(f.cmd, &rpbi, VK_SUBPASS_CONTENTS_INLINE);

    // ImGui 绘制
    ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), f.cmd);

    vkCmdEndRenderPass(f.cmd);

    check_vk(vkEndCommandBuffer(f.cmd), "vkEndCommandBuffer");

    // 提交
    VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    VkSubmitInfo si{VK_STRUCTURE_TYPE_SUBMIT_INFO};
    si.waitSemaphoreCount = 1;
    si.pWaitSemaphores = &gFrames[0].imageAvailable; // 注意：用 per-image 的也可以
    si.pWaitDstStageMask = &waitStage;
    si.commandBufferCount = 1;
    si.pCommandBuffers = &f.cmd;
    si.signalSemaphoreCount = 1;
    si.pSignalSemaphores = &f.renderFinished;
    check_vk(vkQueueSubmit(gGraphicsQueue, 1, &si, f.inFlight), "vkQueueSubmit");

    // 呈现
    VkPresentInfoKHR pi{VK_STRUCTURE_TYPE_PRESENT_INFO_KHR};
    VkSwapchainKHR swapchains[] = { gVkbSwapchain.swapchain };
    pi.swapchainCount = 1;
    pi.pSwapchains = swapchains;
    pi.pImageIndices = &imageIndex;
    pi.waitSemaphoreCount = 1;
    pi.pWaitSemaphores = &f.renderFinished;

    VkResult pres = vkQueuePresentKHR(gGraphicsQueue, &pi);
    if (pres == VK_ERROR_OUT_OF_DATE_KHR || pres == VK_SUBOPTIMAL_KHR) {
        rebuild_swapchain();
        return;
    }
    check_vk(pres, "vkQueuePresentKHR");
}


static void init_vulkan() {
    // Instance
    vkb::InstanceBuilder builder;
    auto inst_ret = builder
        .set_app_name("ImGuiVulkanAndroid")
        .require_api_version(1,1,0)
        .build();
    if (!inst_ret) { LOGE("Instance build failed"); abort(); }
    gVkbInstance = inst_ret.value();
    gInstance = gVkbInstance.instance;

    create_surface_from_window();
    create_swapchain_and_views();
}

static void init_all() {
    init_vulkan();
    init_imgui_backend();
    gInitialized = true;
}

static void shutdown_all() {
    vkDeviceWaitIdle(gDevice);

    ImGui_ImplVulkan_Shutdown();
    ImGui_ImplAndroid_Shutdown();
    ImGui::DestroyContext();

    destroy_swapchain_objects();

    if (gImguiDescPool) vkDestroyDescriptorPool(gDevice, gImguiDescPool, nullptr);
    if (gPipelineCache) vkDestroyPipelineCache(gDevice, gPipelineCache, nullptr);

    if (gVkbSwapchain.swapchain) vkb::destroy_swapchain(gVkbSwapchain);
    if (gDevice) vkb::destroy_device(gVkbDevice);
    if (gSurface) vkDestroySurfaceKHR(gInstance, gSurface, nullptr);
    if (gInstance) vkb::destroy_instance(gVkbInstance);

    if (gWindow) { ANativeWindow_release(gWindow); gWindow = nullptr; }

    gInitialized = false;
}